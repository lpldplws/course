# 3.9内容

## 防抖节流

概念

手写防抖节流

时间戳节流

## setTimeout

### 入参出参

```JS
var timeoutID = scope.setTimeout(function[, delay, param1, param2, ...]);
var timeoutID = scope.setTimeout(function[, delay]); 
var timeoutID = scope.setTimeout(code[, delay]);
```

入参：
- function: 必须
- delay: 延时时间，在延时后的循环的macro栈中执行
- args: 剩余参数作为fn的入参

出参：
Number: timeoutID
为定时器编号，可用clearTimeout清除
需要注意的是setTimeout()和setInterval()共用一个编号池，技术上，clearTimeout()和 clearInterval() 可以互换。但是，为了避免混淆，不要混用取消定时函数。

同一个对象上（一个window或者worker），setTimeout()或者setInterval()在后续的调用不会重用同一个定时器编号。但是不同的对象使用独立的编号池。

### polyfill

解决低版本浏览器不支持传args

```JS
/*\
|*|
|*|  Polyfill which enables the passage of arbitrary arguments to the
|*|  callback functions of JavaScript timers (HTML5 standard syntax).
|*|
|*|  https://developer.mozilla.org/en-US/docs/DOM/window.setInterval
|*|
|*|  Syntax:
|*|  var timeoutID = window.setTimeout(func, delay[, param1, param2, ...]);
|*|  var timeoutID = window.setTimeout(code, delay);
|*|  var intervalID = window.setInterval(func, delay[, param1, param2, ...]);
|*|  var intervalID = window.setInterval(code, delay);
|*|
\*/

(function() {
  setTimeout(function(arg1) {
    if (arg1 === 'test') {
      // feature test is passed, no need for polyfill
      return;
    }
    var __nativeST__ = window.setTimeout;
    window.setTimeout = function(vCallback, nDelay /*, argumentToPass1, argumentToPass2, etc. */ ) {
      var aArgs = Array.prototype.slice.call(arguments, 2);
      return __nativeST__(vCallback instanceof Function ? function() {
        vCallback.apply(null, aArgs);
      } : vCallback, nDelay);
    };
  }, 0, 'test');

  var interval = setInterval(function(arg1) {
    clearInterval(interval);
    if (arg1 === 'test') {
      // feature test is passed, no need for polyfill
      return;
    }
    var __nativeSI__ = window.setInterval;
    window.setInterval = function(vCallback, nDelay /*, argumentToPass1, argumentToPass2, etc. */ ) {
      var aArgs = Array.prototype.slice.call(arguments, 2);
      return __nativeSI__(vCallback instanceof Function ? function() {
        vCallback.apply(null, aArgs);
      } : vCallback, nDelay);
    };
  }, 0, 'test');
}())
```

### setTimeout中this问题

由setTimeout()调用的代码运行在与所在函数完全分离的执行环境上。这会导致，这些代码中包含的 this 关键字在非严格模式会指向 window (或全局)对象，严格模式下为 undefined，这和所期望的this的值是不一样的。

为使this指向执行函数作用于

- 匿名函数包住执行函：
```JS
    setTimeout(function(){myArray.myMethod()}, 2000); // prints "zero,one,two" after 2 seconds
    setTimeout(function(){myArray.myMethod('1')}, 2500); // prints "one" after 2.5 seconds
```
- 箭头函数
```JS
    setTimeout(() => {myArray.myMethod()}, 2000); // prints "zero,one,two" after 2 seconds
    setTimeout(() => {myArray.myMethod('1')}, 2500); // prints "one" after 2.5 seconds
```
- Function.prototype.call
```JS
    // Enable the passage of the 'this' object through the JavaScript timers

    var __nativeST__ = window.setTimeout, __nativeSI__ = window.setInterval;

    window.setTimeout = function (vCallback, nDelay /*, argumentToPass1, argumentToPass2, etc. */) {
        var oThis = this, aArgs = Array.prototype.slice.call(arguments, 2);
        return __nativeST__(vCallback instanceof Function ? function () {
            vCallback.apply(oThis, aArgs);
        } : vCallback, nDelay);
    };

    window.setInterval = function (vCallback, nDelay /*, argumentToPass1, argumentToPass2, etc. */) {
        var oThis = this, aArgs = Array.prototype.slice.call(arguments, 2);
        return __nativeSI__(vCallback instanceof Function ? function () {
            vCallback.apply(oThis, aArgs);
        } : vCallback, nDelay);
    };
```

### 传参为字符串

向setTimeout()传递一个字符串而不是函数会遭受到与使用eval一样的风险

```JS
window.setTimeout("alert(\"Hello World!\");", 500); // 不推荐
```

### 了解：setTimeout回调最短时间


参考：[https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setTimeout](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setTimeout)